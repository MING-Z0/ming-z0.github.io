<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>全面理解STL-vector容器与迭代器入门 | MINGの部落格</title><meta name="keywords" content="CPP,STL,开发语言"><meta name="author" content="Ming"><meta name="copyright" content="Ming"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="全面理解STL-vector容器与迭代器入门"><meta name="application-name" content="全面理解STL-vector容器与迭代器入门"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="全面理解STL-vector容器与迭代器入门"><meta property="og:url" content="https://ming-z0.github.io/2024/10/21/CPP/标准库/二、vector容器与迭代器入门/index.html"><meta property="og:site_name" content="MINGの部落格"><meta property="og:description" content="vector容器构造显式构造指定一个参数 explicit vector(size_t n)1234567#include &amp;lt;vector&amp;gt;using namespace std;int main()&amp;amp;#123;    vector&amp;lt;int&amp;gt; a;    return 0;&amp;amp;"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://ming-z0.github.io/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/1.jpg"><meta property="article:author" content="Ming"><meta property="article:tag" content=" "><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://ming-z0.github.io/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/1.jpg"><meta name="description" content="vector容器构造显式构造指定一个参数 explicit vector(size_t n)1234567#include &amp;lt;vector&amp;gt;using namespace std;int main()&amp;amp;#123;    vector&amp;lt;int&amp;gt; a;    return 0;&amp;amp;"><link rel="shortcut icon" href="/img/%E9%85%8D%E7%BD%AE/%E5%A4%B4%E5%83%8F.jpg"><link rel="canonical" href="https://ming-z0.github.io/2024/10/21/CPP/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%8C%E3%80%81vector%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%85%A5%E9%97%A8/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "i5biwbw9sk");</script><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 休息休息吧！","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://vercel-c6qs1so68-mings-projects-7cb05430.vercel.app/',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"cdn","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"距离上次更新已经过去了","messageNext":"天，文章的内容可能已经过时。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Ming","link":"链接: ","source":"来源: MINGの部落格","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'MINGの部落格',
  title: '全面理解STL-vector容器与迭代器入门',
  postAI: '',
  pageFillDescription: 'vector容器, 构造, 显式构造, 指定一个参数 explicit vector(size_t n), 指定两个参数 explicit vector(size_t n int const ampval), 初始化列表构造, 小技巧, operator[], at()函数, resize()函数, clear()函数, push_back()函数, pop_back()函数, back()函数, front()函数, data()获取首地址指针, RAII思想避免内存泄露, 生命周期管理, 延续生命周期, resize()和内存管理, resize到更大尺寸会导致data失效, resize到更小尺寸不会导致data失效, capacity()函数查询实际的最大容量, resize()的优化策略, reserve()预留一定容量避免之后重复分配, shrink_t0_fit()释放多余的容量, 一个小工具：mallochook, puch_back()的问题, 解决：reserve(), clear()的问题, 解决：shrink_to_fit(), 迭代器入门, 迭代器的引入, 迭代器结构的出现, 首指针 + 尾指针, 模板实现, 不连续内存的容器, 首迭代器 + 尾迭代器, 迭代器中++的前置和后置, insert()函数, 头部插入, 特定位置插入, 重复插入多个相同的值, 直接插入一个初始化列表, 直接插入另一个vector, 数据源可是是不同类型, 构造函数也接受迭代器, assign()函数, erase()函数, 指定位置, 指定区间容器构造显式构造指定一个参数的功能是长度可变的数组他里面的数据存储在堆上使用会得到的大小是即三个指针的大小第一个指针指向堆上内存的起始地址第二个指针标志着有效元素结束位置第三个指针指向分配给的总容量位置表示可以存储多少元素而不需要重新分配内存是一个模板类第一个模板参数是数组里元素的类型例如声明一个元素是类型的动态数组可以为运行时变量不一定为常量输出可以在构造时指定初始长度例如要创建一个长度为的型数组之后可以通过获得数组的长度比如上面的代码会得到另外的这个显式构造函数默认会把所有元素都初始化为不必手动去如果是其他自定义类则会调用元素的默认构造函数例如数字类型会初始化为会初始化为空字符串指针类型会初始化为自定义打印详见本节小技巧可以为运行时变量不一定为常量输出指定两个参数这个显式构造函数还可以指定第二个参数这样就可以用以外的值初始化整个数组了输出比如要创建个组成的数组就可以写等价于初始化列表构造除了先指定大小再一个个构造之外还可以直接利用初始化列表新特性在构造时就初始化其中元素的值例如创建具有四个元素的和刚刚先创建再赋值的方法相比更直观初始化表达式的等号可以写也可以不写都是等价的注意这意味着如果用花括号的初始化会得到长度为只有一个元素的数组如果需要长度为元素全部为的数组必须用圆括号而不是花括号这样才能保证调用他的显式构造函数会得到长度为元素全为的数组输出这在对于只能用花括号初始化的类成员来说就有很大问题会得到长度为只有一个元素的数组但还是可以用这种写法强制调用显式构造函数会得到长度为元素全为的数组小技巧添加一个运算符重载用于打印类型输出要访问里的元素只需用运算符例如访问第个元素人类的第一个例如访问第个元素人类的第二个值得注意的是运算符在索引超出数组大小时并不会直接报错这是为了性能的考虑越界访问输出越界访问如果你不小心用访问了越界的索引可能会覆盖掉别的变量导致程序行为异常或是访问到操作系统未映射的区域导致奔溃函数输出为了防止不小心越界可以用替代函数会检测索引是否越界如果他发现索引则会抛出异常让程序提前终止或者被捕获配合任意一款调试器就可以很快速地定位到出错点不过需要额外检测下标是否越界虽然更安全方便调试但和相比有一定性能损失上面只演示了读取操作当然可以使用和进行写入操作函数除了可以在构造函数中指定数组的大小还可以之后再通过函数设置大小输出这在无法一开始就指定大小的情况下非常方便当然也有一个接受第二参数的重载他会用这个参数的值填充所有新建的元素输出调用的时候如果数组里面不足个元素假设是个则他只会用填充新增的个元素前个元素会保持不变等价于输出调用的时候如果数组已有超过个元素假设是个则他会删除多出来的个元素前个元素会保持不变等价于输出调用第二个重载的时候如果数组里面不足个元素假设是个则他只会用第二个参数填充新增的个元素前个元素会保持不变等价于输出调用第二个重载的时候如果数组已有超过个元素假设是个则第二参数会被无视删除多出来的个元素前个元素会保持不变等价于输出函数的函数可以清空该数组也就相当于把长度设为零变成空数组例如等价于或通常用于后面需要重新因此可以来把数组设为空配合会保留原数组的前面部分不变只在后面填充上具有一定软弱性如果需要把原数组前面的部分也填充上可以先再这是一个常见的组合输出函数新增输出可以在数组的末尾追加一个数例如等价于函数输出函数则是和唱反调他是在数组的末尾删除一个数例如等价于函数输出要注意的是函数的返回类型是也就是没有返回值如果需要获取删除的值可以在之前先通过获取末尾元素的值实现效果等价于函数输出和相对的还有一个返回末尾元素的引用而返回首个元素的引用等价于获取首地址指针输出会返回指向数组中首个元素的指针也就是等价于由于是连续存储的数组因此只要得到了首地址下一个元素的地址只需指针即可因为指针的相当于因此可以把返回的首地址指针当一个数组来访问输出返回的首地址指针通常配合返回的数组长度一起使用连续的动态数组只需要知道首地址和数组长度即可完全确定用他来获取一个语言原始指针很方便用于调用语言的函数和等同时还能享受到容器的安全性思想避免内存泄露资源获取即初始化使用局部对象来管理资源的技术称为资源获取即初始化利用栈对象自动销毁的特点来实现通过构造函数获取资源通过析构函数释放资源如果用或者就很容易出现忘记释放内存的情况造成内存泄露使用容易忘记释放而会在离开作用域时自动调用解构函数释放内存就不必手动释放了更安全使用通过配合语言操作离开作用域时自动释放获取的指针也会失效生命周期管理中最神奇的运算符标志着一个语句块的结束在这里他会调用所有身处其中的对象的解构函数比如这里的他的解构函数会释放动态数组的内存即自动会在退出作用域时释放内存这时候所有指向其中元素的指针包括都会失效因此如果你是在语句块内获取的指针语句块外就无法访问了可见指针是对的一种引用实际对象生命周期仍由类本身管理离开作用域输出无效数延续生命周期全局变量退出释放与生命周期相同离开作用域输出如果需要在一个语句块外仍然保持对数组的弱引用有效可以把语句块内的对象移动到外面的一个对象上在移动时指针不会失效例如则会把变成空数组指向原来所包含的元素数组且地址不变之后即使不直接使用外面的那个临时对象也可以继续通过指针来访问数据也可以移动到一个全局变量的对象这样数组就会一直等到退出了才释放规定全局变量都会在进入函数之前构造函数返回之后解构和内存管理到更大尺寸会导致失效输出输出当的目标长度大于原有的容量时就需要重新分配一段更大的连续内存并把原数组长度的部分移动过去多出来的部分则用来填充这就导致元素的地址会有所改变从而过去返回的指针以及所有的迭代器对象都会失效到更小尺寸不会导致失效输出当的目标长度小于原有的容量时不需要重新分配一段连续的内存也不会造成元素的移动这个设计是为了性能考虑所以指向元素的指针不会失效他只是会把数组的长度标记为新长度后面空闲出来那一段内存不会释放掉继续留在那里直到对象被解构重新到原来也不会导致失效调用了之后数组的容量仍然是因此重新扩容到是不需要重新分配内存的也就不会移动元素导致指针失效函数查询实际的最大容量输出可以用函数查询已经分配内存的大小即最大容量而返回的其实是已经存储了数据的数组长度可以发现当指定的新长度一个超过原来的最大容量时时就会重新分配一段更大容量的内存来存储数组只有这时才会移动元素的位置指针失效的优化策略注意这里之后容量实际上扩充到了而不是刚好为什么因为标准库的设计者非常聪明他料想到了你以后可能还会来个甚至之类的为了减少重复分配的次数他有一个策略当后的新尺寸变化较小时则自动扩容至原尺寸的两倍这里我们的原大小是所以会扩充容量到但是尺寸为尺寸总是小于等于容量尺寸范围内都是已初始化的内存零寸到容量之间的范围是未初始化的输出不过如果后的尺寸还超过了原先尺寸的两倍就没有这个效果了也就是说的逻辑是扩容至预留一定容量避免之后重复分配预留输出内存分配是需要一定时间的如果我们程序员能预料到数组最终的大小可以用函数预留一定的容量这样之后就不会出现容量不足而需要动态扩容影响性能了例如这里我们一开始预留了格容量这样从到的时候就不必重新分配此外还要注意时也会移动元素释放多余的容量刚刚说过当到一个更小的大小上时多余的容量不会释放而是继续保留如担心内存告急可以用释放掉多余的容量只保留刚好为大小的容量输出会重新分配一段更小内存他同样是会把元素移动到新内存中的因此迭代器和指针也会失效一个小工具为了追踪所有的内存分配与释放我们试着重写一下和函数这样当容器分配或是释放内存的时候我们就能轻松看到不过这个只能系统可以用哦的问题输出由于不知道你究竟会推入多少个元素的初始容量是零而和一样每次遇到容量不足时都会扩容两倍例如上面的输出这也体现了实际容量和数组大小分离的好处如果死板地让分配的内存容量始终等于当前数组大小很多同学都号称自己实现过都是这种写法那么如果要用推入个元素就需要重新分配内存次移动元素次而像标准库这样允许数组大小和实际容量不同这样在容量不足的时候就可以一次性扩容两倍只需重新分配次移动元素次解决因此如果你早就知道要推入元素的数量可以调用函数先预留那么多的容量等待接下来的推入预留空间输出这样之后时就不会一次次地扩容两倍慢慢成长到避免重新分配内存和移动元素更高效比如这里我们可以提前知道循环会执行次因此就可以了可以看到只有一次之后那次是造成的不必在意的问题刚刚说过相当于所以他也不会实际释放掉内存容量还是摆在那里仅仅只是把数组大小标记为而已输出这可能导致在低端平台上内存告急这是因为尽管你已经掉了而实际容量还在并没有释放解决要真正释放掉内存可以在之后再调用这样才会让容量也变成这时的会返回输出当然对象解构时也会彻底释放内存这个不用操心配合只是提前释放而已迭代器入门迭代器的引入迭代器结构的出现我们都知道可以使用一个函数来封装打印操作但是这样的缺点是它智能打印类型没法打印类型要想支持只能再实现另一个函数注意到和的底层都是连续的稠密数组他们都有和函数因此可改用首地址指针和数组长度做参数这样在无需知道容器具体类型的情况下只用最简单的接口首地址指针就完成了遍历和打印的操作使用指针和长度做接口的好处是可以通过给指针加减运算选择其中一部分连续的元素来打印而不一定全部打印出来比如这里我们选择打印前三个元素去掉了最后一个元素但不必用修改数组只要传参数的时候修改一下长度部分即可选择打印后三个元素去掉了第一个元素但不必用修改数组只要传参数的时候同时修改指针和长度接着我们发现首地址指针和数组长度看起来不太对称不妨改用首地址指针和尾地址指针如何注意看我们在里也不是用数组下标去迭代而是用指针作为迭代变量了首指针尾指针改用首地址指针和尾地址指针以后要特别注意一点尾地址指针实际上是指向末尾元素再往后后一个元素的指针输出随机值也就是说尾地址指针所指向的地方是无效的内存尾地址指针减才是真正的末尾元素指针为什么要这样设计因为如果用也就是作为尾地址指针将无法表示数组长度为的情况而让尾地址指针往后移动一格的设计使得数组长度为就是的情况非常容易判断更方便的是你可以通过指针的减法运算来算出数组的长度输出循环里也很容易写判断是否继续循环的条件为就行了模板实现最后我们可以让首指针和尾指针声明为模板参数这样不论指针是什么类型都可以使用这个模板函数来打印输出不连续内存的容器首指针和尾指针的组合的确能胜任这种连续数组但是对于这种不连续的内存的容器就没辙了没错没有这个成员函数因为他根本就不连续首迭代器尾迭代器然而却提供了和函数他们会返回两个对象输出这个是一个特殊定义过的类型其具有和以及这些运算符的重载所以用起来就像普通的指针一样而这些运算符重载却会把对应到链表的上这样一个用起来就像普通的指针但内部却通过运算符重载适配不同容器的特殊类就是迭代器迭代器是中容器和算法之间的桥梁如果让我们来写容器和他的迭代器他的内部具体实现可能是这样的迭代器的这些运算符都是约定俗成的其根本目的在于模仿指针的行为方便来自语言的程序员快速上手掌握标准库虽然你也可以用直观的函数名代替用代替代替但是模仿指针行为的这些运算符已然成为了事实上的标准而且也非常简洁明了因此所有的用户和库都会按照这套运算符标准来实现和使用迭代器建立起了沟通的桥梁节省了各自创立一套规范的成本迭代器中的前置和后置迭代器的自增运算符分为和两种写法他们都会产生的效果但是有一个细微的区别就是他们被作为表达式时的返回值前置自增此运算符会先将迭代器自增然后返回自增后的迭代器本身由于返回的是左值引用因此可以继续进行自增操作例如后置自增此运算符会先返回自增前的迭代器值然后再执行自增返回值是一个右值不能被修改正因如此后置自增需要先保存旧的迭代器然后自增自己再返回旧迭代器可能会比较低效在中我们推荐尽可能地多用前置自增在运算符重载上沙雕的标准委员会规定这个重载是后置自增不带任何参数的这个重载是前置自增之所以这样是因为同名函数只能通过参数列表类型来区分这个类型参数没有任何实际意义只是为了区分不同的重载编译器会在的时候自动改成调用这个只是为了区分重载容器中的迭代器和函数可以获取指向第一个元素所在位置的迭代器可以获取指向最后一个元素下一个位置的迭代器迭代器的作用类似于一个位置标记符虽然对于来说只需要下标就能标记位置了例如中也是通过表示第一个元素表示最后一个元素而的特色就是采用了迭代器来标记位置他实际上是一个指针这样的好处是不需要指定原来的容器本身就能知道指定的位置一对迭代器和就标记了一个区间区间可以是一个容器的全部例如区间也可以是一个容器的部分例如相当于去头去尾后的列表相当于中的直接访问是一个无效地址输出随机数可以获取指向第一个元素所在位置的迭代器可以通过来访问第一个元素迭代器支持加法运算例如就是访问数组的第二个元素了和等价可以获取指向最后一个元素下一个位置的迭代器也就是说指向的位置是不可用的如需访问最后一个元素必须用才行输出冷知识迭代器实际上还可以用运算符访问例如这里的就和等价不过只有这种连续的可随机访问容器的迭代器有和运算符对于则只有和和运算符可以用这是迭代器的两个分类详见下一章自此迭代器对象和容器本身的主要区别就在于迭代器不掌握生命周期从而迭代器的拷贝是平凡的浅拷贝方便传参但也带来了缺点因为迭代器是一个对原容器的弱引用如果原容器解构或发生内存重分配迭代器就会失效函数头部插入输出我们知道可以往尾部插入数据那么如何往头部插入数据呢用函数他的第一个参数是要插入的位置用迭代器表示第二个参数则是要插入的值注意这个函数的复杂度是是从插入位置到数组末尾的距离没错他会插入位置后方的元素整体向后移动一格是比较低效的因此为了高效我们尽量只往尾部插入元素如果需要高效的头部插入可以考虑用容器他有高效的函数替代在容量不足时同样会造成重新分配以求扩容会移动其中所有元素这时所有之前保存的迭代器都会失效特定位置插入输出如果要插入到一个特定位置可以用迭代器的加法来获取某一位置的迭代器例如就会指向第三个元素那么用这个作为的参数就会把这个值插到第三个元素的位置之前插入位置是倒数第二个输出可以插入到开头位置可以插入到第二个元素位置可以插入到最末尾则是插入到倒数第一个元素前迭代器的减法和是中负数作为下标的情况很像的不过更加明确是从开始往前数的重复插入多个相同的值输出还有一个特殊的功能就是他可以插入一个元素很多遍只需多指定一个参数来表示插入多少遍语法如下插入位置重复多少次插入的值你可能会担心刚刚不是说在头部是复杂度嘛那如果再重复次岂不是复杂度了当然不会的这个重载会一次性批量让之后的元素移动格不存在反复移动格的情况最坏复杂度仍然是如果你自己写个循环反复调那的确是会了这就是为什么提供这个高效的重载专门负责重复插入的操作直接插入一个初始化列表输出还可以直接插入一个的列表这个花括号形成的列表就是传说中的初始化列表是新增的功能例如这里这个列表的类型是插入位置插入值插入值这个的最坏复杂度同样是的并且因为其内部预先知道了要插入列表的长度会一次性完成扩容比重复调用重复扩容要高效很多直接插入另一个能否传入一个作为参数呢直接传入对象输出直接传入对象不可以因为和不是同一个类型那要如何插入另一个数组或者说把和两个数组进行合并通过迭代器这里可以是其他容器的迭代器类型传入区间输出记得的迭代器思想是容器和算法之间的交互不是通过容器对象本身而是他的迭代器因此设计时就决心不支持直接接受作参数而是接受他的两个迭代器组成的区间好处有可以批量插入从来自另一个不同类型的容器例如只要元素类型相等且符合迭代器规范我可以自由选择对方容器的一个子区间通过迭代器加减法内的元素来插入而不是死板的只能全部插入刚才会把插入在原先元素之前相当于的可以改用把插入到元素之后相当于的这样性能更好只要容量足够就无需移动的全部元素当然也可以这样只插入到指定位置中间似乎没有这个操作数据源可是是不同类型输出对方容器也可以是不同类型的最底线的要求是只要他的迭代器有和运算符即可例如上面的就符合需求甚至可以是一个语言风格的数组新增两个函数输出因为语言类型没有办法加成员函数和可以用和这两个全局函数代替当然如果用了时也可以不写前缀这两个函数会对于具有和成员函数的容器会直接调用对于语言数组则被特化为返回和构造函数也接受迭代器这里可以是其他容器的迭代器类型输出容器的构造函数也接受一对迭代器做参数来初始化其中的元素同样可以是不同容器的迭代器对象只要具有和就行了函数重新分配中的值这里可以是其他容器的迭代器类型输出除了构造函数外这个成员函数也能在后期把元素覆盖进去和不同的是他会把旧有的数组完全覆盖掉变成一个新的数组清空原来的值放入新值注意此时不会重新分配内存基本和等价唯一的区别是后者会重新分配内存而前者会保留原来的容量不会释放掉还有一个重载可以把批量填满一个特定的值重复的次数长度也是参数里指定输出基本和等价唯一的区别是后者会重新分配内存而前者会保留原来的容量还可以直接接受一个初始化列表作为参数输出和完全等价都会保留原来的容量而和就不等价这个会重新分配内存函数指定位置函数可以删除指定位置的一个元素通过迭代器指定输出就是删除第一个元素相当于就是删除最后一个元素相当于就是删除第三个元素就是删除倒数第二个元素的复杂度最坏情况是删除第一个元素如果删的是最后一个元素则复杂度为这是因为会移动之后的那些元素指定区间也可以指定两个迭代器作为参数表示把这个区间内的对象都删除输出比如这里就删除了的第二个和第三个元素相当于的注意的和都是就地操作的例如就和等价前提是小于批量删除的最坏复杂度依然是的不用担心不过这里两个作为参数的迭代器必须是自己这个对象的迭代器不能是其他容器的这点和不一样他返回删除后最后一个元素之后那个位置的迭代器',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2025-08-27 21:26:54',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/%E9%85%8D%E7%BD%AE/%E5%A4%B4%E5%83%8F.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://ming-blog.top/" title="MINGの部落格"><img class="back-menu-item-icon" src="/img/配置/头像.jpg" alt="MINGの部落格"/><span class="back-menu-item-text">MINGの部落格</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/MING-Z0/" title="GitHub"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">MINGの部落格</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><span> 隧道</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><span> 关于本人</span></a></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/./img/%E6%89%93%E8%B5%8F/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="/./img/%E6%89%93%E8%B5%8F/wechat.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AimRT/" style="font-size: 1.05rem;">AimRT<sup>1</sup></a><a href="/tags/CMake/" style="font-size: 1.05rem;">CMake<sup>2</sup></a><a href="/tags/CPP/" style="font-size: 1.05rem;">CPP<sup>21</sup></a><a href="/tags/CUDA/" style="font-size: 1.05rem;">CUDA<sup>10</sup></a><a href="/tags/STL/" style="font-size: 1.05rem;">STL<sup>5</sup></a><a href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" style="font-size: 1.05rem;">并行计算<sup>12</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" style="font-size: 1.05rem;">开发环境<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">开发语言<sup>5</sup></a><a href="/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/" style="font-size: 1.05rem;">机器人<sup>1</sup></a><a href="/tags/%E8%AE%BF%E5%AD%98%E4%BC%98%E5%8C%96/" style="font-size: 1.05rem;">访存优化<sup>1</sup></a><a href="/tags/%E9%9A%8F%E8%AE%B0/" style="font-size: 1.05rem;">随记<sup>5</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">15</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/CPP/" itemprop="url">CPP</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/CPP/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>CPP</span></a><a class="article-meta__tags" href="/tags/STL/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>STL</span></a><a class="article-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>开发语言</span></a></span></div></div><h1 class="post-title" itemprop="name headline">全面理解STL-vector容器与迭代器入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-10-20T16:00:00.000Z" title="发表于 2024-10-21 00:00:00">2024-10-21</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-08-27T13:26:54.843Z" title="更新于 2025-08-27 21:26:54">2025-08-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">14.9k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>68分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="全面理解STL-vector容器与迭代器入门"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/1.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://ming-z0.github.io/2024/10/21/CPP/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%8C%E3%80%81vector%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%85%A5%E9%97%A8/"><header><a class="post-meta-categories" href="/categories/CPP/" itemprop="url">CPP</a><a href="/tags/CPP/" tabindex="-1" itemprop="url">CPP</a><a href="/tags/STL/" tabindex="-1" itemprop="url">STL</a><a href="/tags/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/" tabindex="-1" itemprop="url">开发语言</a><h1 id="CrawlerTitle" itemprop="name headline">全面理解STL-vector容器与迭代器入门</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Ming</span><time itemprop="dateCreated datePublished" datetime="2024-10-20T16:00:00.000Z" title="发表于 2024-10-21 00:00:00">2024-10-21</time><time itemprop="dateCreated datePublished" datetime="2025-08-27T13:26:54.843Z" title="更新于 2025-08-27 21:26:54">2025-08-27</time></header><h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><h4 id="显式构造"><a href="#显式构造" class="headerlink" title="显式构造"></a>显式构造</h4><h5 id="指定一个参数-explicit-vector-size-t-n"><a href="#指定一个参数-explicit-vector-size-t-n" class="headerlink" title="指定一个参数 explicit vector(size_t n)"></a>指定一个参数 <code>explicit vector(size_t n)</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vector 的功能是长度可变的数组，他里面的数据存储在堆上。</p>
<ul>
<li><p>使用<code>sizeof(vector)</code>会得到vector的大小是24，即三个指针的大小</p>
</li>
<li><p>第一个指针指向堆上内存的起始地址</p>
</li>
<li><p>第二个指针标志着有效元素结束位置</p>
</li>
<li><p>第三个指针指向分配给<code>vector</code>的总容量位置，表示<code>vector</code>可以存储多少元素而不需要重新分配内存</p>
</li>
</ul>
<p>vector 是一个模板类，第一个模板参数是数组里元素的类型。</p>
<p>例如，声明一个元素是 int 类型的动态数组 a：<code>vector&lt;int&gt; a;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;<span class="comment">// 可以为运行时变量，不一定为常量</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：4</span></span><br></pre></td></tr></table></figure>

<p>vector 可以在构造时指定初始长度。</p>
<p>例如，要创建一个长度为 4 的 int 型数组：<code>vector&lt;int&gt; a(4);</code></p>
<p>之后可以通过 a.size() 获得数组的长度。比如上面的代码会得到 4。</p>
<p><strong>另外：</strong></p>
<ul>
<li><p>vector 的这个显式构造函数，默认会把所有元素都初始化为 0（不必手动去 memset）。</p>
</li>
<li><p>•如果是其他自定义类，则会调用元素的默认构造函数（例如：数字类型会初始化为 0，string 会初始化为空字符串，指针类型会初始化为 nullptr）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span><span class="comment">//自定义打印，详见本节小技巧</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;<span class="comment">// 可以为运行时变量，不一定为常量</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="指定两个参数-explicit-vector-size-t-n-int-const-val"><a href="#指定两个参数-explicit-vector-size-t-n-int-const-val" class="headerlink" title="指定两个参数 explicit vector(size_t n, int const &amp;val)"></a>指定两个参数 <code>explicit vector(size_t n, int const &amp;val)</code></h5><p>这个显式构造函数还可以指定第二个参数，这样就可以用 0 以外的值初始化整个数组了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>, <span class="number">233</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;233,233,233,233&#125;</span></span><br></pre></td></tr></table></figure>

<p>比如要创建 4 个 233 组成的数组就可以写：</p>
<p><code>vector&lt;int&gt; a(4, 233);</code></p>
<p>等价于</p>
<p><code>vector&lt;int&gt; a = &#123;233, 233, 233, 233&#125;;</code></p>
<h4 id="初始化列表构造"><a href="#初始化列表构造" class="headerlink" title="初始化列表构造"></a>初始化列表构造</h4><p><code>vector(initializer_list&lt;int&gt; list);</code></p>
<p>除了先指定大小再一个个构造之外，还可以直接利用初始化列表（C++11 新特性）在构造时就初始化其中元素的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[1] = &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[2] = &quot;</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[3] = &quot;</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如创建具有 6, 1, 7, 4 四个元素的 vector：</p>
<p><code>vector&lt;int&gt; a = &#123;6, 1, 7, 4&#125;;</code></p>
<p>和刚刚先创建再赋值的方法相比更直观。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[1] = &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[2] = &quot;</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[3] = &quot;</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化表达式的<strong>等号</strong>可以写也可以不写：</p>
<p><code>vector&lt;int&gt; a = &#123;6, 1, 7, 4&#125;;</code></p>
<p><code>vector&lt;int&gt; a&#123;6, 1, 7, 4&#125;;</code></p>
<p>都是等价的。</p>
<p>**注意，**这意味着如果用花括号的 <code>&#123;4&#125; </code>初始化：</p>
<p><code>vector&lt;int&gt; a&#123;4&#125;;</code></p>
<p>会得到长度为 1 只有一个元素 4 的数组。</p>
<p>如果需要长度为 4，元素全部为 0 的数组，必须用圆括号<code> ()</code> 而不是花括号 <code>&#123;&#125;</code>，这样才能保证调用他的显式<code>（explicit）</code>构造函数：</p>
<p><code>vector&lt;int&gt; a(4);</code></p>
<p>会得到长度为 4 元素全为 0 的数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.size() = &quot;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// a[0] = 4</span></span><br><span class="line"><span class="comment">// a.size() = 1</span></span><br></pre></td></tr></table></figure>

<p>这在对于<strong>只能用花括号初始化</strong>的类成员来说，就有很大问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">4</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.a[0] = &quot;</span> &lt;&lt; c.a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.a.size() = &quot;</span> &lt;&lt; c.a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vector&lt;int&gt; a&#123;4&#125;;</code></p>
<p>会得到长度为 1 只有一个元素 4 的数组。</p>
<p>但还是可以用这种写法强制调用显式构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.a[0] = &quot;</span> &lt;&lt; c.a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c.a.size() = &quot;</span> &lt;&lt; c.a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vector&lt;int&gt; a = vector&lt;int&gt;(4);</code></p>
<p>会得到长度为 4 元素全为 0 的数组。</p>
<h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>添加一个运算符重载用于打印 vector 类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	printer.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, vector&lt;T&gt; <span class="type">const</span> &amp;v) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        os &lt;&lt; *it;</span><br><span class="line">        <span class="keyword">for</span> (++it; it != v.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            os &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; *it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="operator"><a href="#operator" class="headerlink" title="operator[]"></a>operator[]</h3><p><code>int &amp;operator[](size_t i) noexcept;</code></p>
<p><code>int const &amp;operator[](size_t i) const noexcept;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[1] = &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[2] = &quot;</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[3] = &quot;</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a[0] = 0</span></span><br><span class="line"><span class="comment">//a[1] = 0</span></span><br><span class="line"><span class="comment">//a[2] = 0</span></span><br><span class="line"><span class="comment">//a[3] = 0</span></span><br></pre></td></tr></table></figure>

<p>要访问 vector 里的元素，只需用 [] 运算符：</p>
<ul>
<li><p>例如 a[0] 访问第 0 个元素（人类的第一个）</p>
</li>
<li><p>例如 a[1] 访问第 1 个元素（人类的第二个）</p>
</li>
</ul>
<p><strong>值得注意</strong>的是，<code>[]</code> 运算符在索引超出数组大小时并不会直接报错，这是为了性能的考虑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[1] = &quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[2] = &quot;</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[3] = &quot;</span> &lt;&lt; a[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[1000] = &quot;</span> &lt;&lt; a[<span class="number">1000</span>] &lt;&lt; endl;<span class="comment">// 越界访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a[0] = 0</span></span><br><span class="line"><span class="comment">//a[1] = 0</span></span><br><span class="line"><span class="comment">//a[2] = 0</span></span><br><span class="line"><span class="comment">//a[3] = 0</span></span><br><span class="line"><span class="comment">//a[100] = 0	//越界访问</span></span><br></pre></td></tr></table></figure>



<p>如果你不小心用<code> []</code>访问了越界的索引，可能会覆盖掉别的变量导致程序行为异常，或是访问到操作系统未映射的区域导致奔溃。</p>
<h3 id="at-函数"><a href="#at-函数" class="headerlink" title="at()函数"></a><code>at()</code>函数</h3><p><code>int &amp;at(size_t i);</code></p>
<p><code>int const &amp;at(size_t i) const;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.at(0) = &quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.at(1) = &quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.at(2) = &quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.at(3) = &quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.at(1000) = &quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">1000</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a.at(0) = 0</span></span><br><span class="line"><span class="comment">// a.at(1) = 0</span></span><br><span class="line"><span class="comment">// a.at(2) = 0</span></span><br><span class="line"><span class="comment">// a.at(3) = 0</span></span><br><span class="line"><span class="comment">// terminate called after throwing an instance of &#x27;std::out_of_range&#x27;</span></span><br><span class="line"><span class="comment">//   what():  vector::_M_range_check: __n (which is 1000) &gt;= this-&gt;size() (which is 4)</span></span><br></pre></td></tr></table></figure>

<p>为了防止不小心越界，可以用 <code>a.at(i)</code> 替代 <code>a[i]</code>，&#96;&#96;at<code> 函数会检测索引 i 是否越界，如果他发现索引</code> i &gt;&#x3D; a.size() <code>则会抛出异常 </code>std::out_of_range<code>让程序提前终止（或者被</code>try-catch &#96;捕获），配合任意一款调试器，就可以很快速地定位到出错点。</p>
<p>不过 <code>at</code> 需要额外检测下标是否越界，虽然更安全方便调试，但和 <code>[]</code> 相比有一定性能损失。</p>
<ul>
<li>上面只演示了读取操作，当然可以使用<code>[]</code>和<code>at</code>进行写入操作</li>
</ul>
<h3 id="resize-函数"><a href="#resize-函数" class="headerlink" title="resize()函数"></a><code>resize()</code>函数</h3><p><code>void resize(size_t n);</code></p>
<p>除了可以在构造函数中指定数组的大小，还可以之后再通过 resize 函数设置大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="comment">//&#123;0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure>

<p>这在无法一开始就指定大小的情况下非常方便。</p>
<p>当然，resize 也有一个接受第二参数的重载，他会用这个参数的值填充所有新建的元素。</p>
<p><code>void resize(size_t n, int const &amp;val);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="comment">//&#123;233,233,233,233&#125;</span></span><br></pre></td></tr></table></figure>

<p>调用 resize(n) 的时候，如果数组里面不足 n 个元素，假设是 m 个，则他<strong>只会用</strong> <strong>0</strong> <strong>填充新增的</strong> <strong>n - m</strong> <strong>个元素</strong>，前 m 个元素会保持不变。</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2&#125;;</code></p>
<p><code>a.resize(4);</code></p>
<p>等价于：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 0, 0&#125;;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br><span class="line"><span class="comment">//&#123;1,2,0,0&#125;</span></span><br></pre></td></tr></table></figure>

<p>调用 <code>resize(n)</code> 的时候，如果数组已有超过 n 个元素，假设是 m 个，则他<strong>会删除多出来的</strong> <strong>m - n</strong> <strong>个元素</strong>，前 n 个元素会保持不变。</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 3, 4, 5, 6&#125;;</code></p>
<p><code>a.resize(4);</code></p>
<p>等价于：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 3, 4&#125;;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="comment">//&#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>调用第二个重载 resize(n, val) 的时候，如果数组里面不足 n 个元素，假设是 m 个，则他<strong>只会用第二个参数</strong> <strong>val</strong> <strong>填充新增的</strong> <strong>n - m</strong> <strong>个元素</strong>，前 m 个元素会保持不变。</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2&#125;;</code></p>
<p><code>a.resize(4, 233);</code></p>
<p>等价于：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 233, 233&#125;;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br><span class="line"><span class="comment">//&#123;1,2,233,233&#125;</span></span><br></pre></td></tr></table></figure>

<p>调用第二个重载 resize(n, val) 的时候，如果数组已有超过 n 个元素，假设是 m 个，则第二参数 val 会被<strong>无视</strong>，<strong>删除多出来的</strong> <strong>m - n</strong> <strong>个元素</strong>，前 n 个元素会保持不变。</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 3, 4, 5, 6&#125;;</code></p>
<p><code>a.resize(4, 233);</code></p>
<p>等价于：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 3, 4&#125;;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2,3,4,5&#125;</span></span><br><span class="line"><span class="comment">//&#123;1,2,3,4&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="clear-函数"><a href="#clear-函数" class="headerlink" title="clear()函数"></a><code>clear()</code>函数</h3><p><code>void clear() noexcept</code></p>
<p>vector 的 clear 函数可以<strong>清空该数组</strong>，也就相当于把长度设为零，变成空数组。例如：</p>
<p><code>a.clear();</code></p>
<p>等价于：</p>
<p><code>a.resize(0);  或  a = &#123;&#125;;</code></p>
<p>通常用于后面需要重新 push_back，因此可以 clear 来把数组设为空。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>clear配合resize</strong></p>
<p>resize 会保留原数组的前面部分不变，只在后面填充上 0。(具有一定软弱性)</p>
<p>如果需要把原数组前面的部分也填充上 0，可以<strong>先</strong> <strong>clear</strong> <strong>再</strong> <strong>resize</strong>，这是一个常见的组合。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br><span class="line"><span class="comment">//&#123;0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="push-back-函数"><a href="#push-back-函数" class="headerlink" title="push_back()函数"></a><code>push_back()</code>函数</h3><p><code>void push_back(int const &amp;val);</code></p>
<p><code>void push_back(int &amp;&amp;val); // C++11 新增</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br><span class="line"><span class="comment">//&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以<strong>在数组的末尾追加</strong>一个数。例如：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2&#125;;</code></p>
<p><code>a.push_back(3);</code></p>
<p>等价于：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 3&#125;;</code></p>
<h3 id="pop-back-函数"><a href="#pop-back-函数" class="headerlink" title="pop_back()函数"></a><code>pop_back()</code>函数</h3><p><code>void pop_back() noexcept</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br></pre></td></tr></table></figure>

<p>pop_back 函数则是和 push_back 唱反调，他是<strong>在数组的末尾删除</strong>一个数。例如：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2, 3&#125;;</code></p>
<p><code>a.pop_back();</code></p>
<p>等价于：</p>
<p><code>vector&lt;int&gt; a = &#123;1, 2&#125;;</code></p>
<h3 id="back-函数"><a href="#back-函数" class="headerlink" title="back()函数"></a><code>back()</code>函数</h3><p><code>int &amp;back() noexcept;</code></p>
<p><code>int const &amp;back() const noexcept</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> val = a.<span class="built_in">back</span>();</span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;back = &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line"><span class="comment">//back = 3</span></span><br><span class="line"><span class="comment">//&#123;1,2&#125;</span></span><br></pre></td></tr></table></figure>

<p>要注意的是 <code>pop_back</code> 函数的返回类型是 <code>void</code>，也就是没有返回值，如果需要获取删除的值，可以在 <code>pop_back()</code> 之前先通过 <code>back()</code> <strong>获取末尾元素的值</strong>，实现 pop 效果。</p>
<p><code>a.back();</code></p>
<p>等价于：</p>
<p><code>a[a.size() - 1]</code></p>
<h3 id="front-函数"><a href="#front-函数" class="headerlink" title="front()函数"></a><code>front()</code>函数</h3><p><code>int &amp;front() noexcept;</code></p>
<p><code>int const &amp;front() const noexcept;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[0] = &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a[a.size() - 1] = &quot;</span> &lt;&lt; a[a.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.front() = &quot;</span> &lt;&lt; a.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.back() = &quot;</span> &lt;&lt; a.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// a[0] = 1</span></span><br><span class="line"><span class="comment">// a[a.size() - 1] = 3</span></span><br><span class="line"><span class="comment">// a.front() = 1</span></span><br><span class="line"><span class="comment">// a.back() = 3</span></span><br></pre></td></tr></table></figure>

<p>和 <code>back()</code> 相对的还有一个 <code>front()</code>。</p>
<p><code>back()</code> 返回<strong>末尾元素</strong>的引用 <code>a[a.size() - 1]</code>。</p>
<p>而 <code>front()</code> 返回<strong>首个元素</strong>的引用 <code>a[0]</code>。</p>
<p><code>a.front();</code></p>
<p>等价于：</p>
<p><code>a[0]</code></p>
<h3 id="data-获取首地址指针"><a href="#data-获取首地址指针" class="headerlink" title="data()获取首地址指针"></a><code>data()</code>获取首地址指针</h3><p><code>int *data() noexcept;</code></p>
<p><code>int const *data() const noexcept;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">//int n = a.size();</span></span><br><span class="line">    <span class="comment">//memset(p, -1, sizeof(int) * n);</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>data() 会返回指向数组中<strong>首个元素的指针</strong>，也就是等价于 &amp;a[0]。由于 vector 是连续存储的数组，因此只要得到了首地址，下一个元素的地址只需指针 +1 即可。</p>
<p>因为指针的 p[i] 相当于 *(p + i)，因此可以把 data() 返回的首地址指针当一个数组来访问。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//&#123;-1,-1,-1,-1,-1&#125;</span></span><br></pre></td></tr></table></figure>

<p>data() 返回的<strong>首地址指针</strong>，通常配合 size() 返回的<strong>数组长度</strong>一起使用（连续的动态数组只需要知道首地址和数组长度即可完全确定）。</p>
<p>用他来获取一个 C 语言原始指针 int *，很方便用于调用 C 语言的函数和 API 等，同时还能享受到 vector 容器 RAII 的安全性。</p>
<h3 id="RAII思想避免内存泄露"><a href="#RAII思想避免内存泄露" class="headerlink" title="RAII思想避免内存泄露"></a>RAII思想避免内存泄露</h3><p>RAII: 资源获取即初始化，使用局部对象来管理资源的技术称为资源获取即初始化。利用栈对象自动销毁的特点来实现，<strong>通过构造函数获取资源，通过析构函数释放资源</strong>。</p>
<p>如果用 new&#x2F;delete 或者 malloc&#x2F;free 就很容易出现忘记释放内存的情况，造成内存泄露。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pixels = <span class="keyword">new</span> <span class="type">char</span>[camera-&gt;m_nx * camera-&gt;m_ny * <span class="number">3</span>];	<span class="comment">//使用new</span></span><br><span class="line"><span class="built_in">CHECK_GL</span>(<span class="built_in">glReadPixels</span>(<span class="number">0</span>, <span class="number">0</span>, camera-&gt;m_nx,camera-&gt;m_ny, GL_RGB,GL_UNSIGNED_BYTE, pixels));</span><br><span class="line"><span class="keyword">delete</span> pixels;	<span class="comment">//容易忘记释放</span></span><br></pre></td></tr></table></figure>

<p>而 vector 会在离开作用域时，自动调用解构函数，释放内存，就不必手动释放了，更安全。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">pixels</span><span class="params">(camera-&gt;m_nx * camera-&gt;m_ny * <span class="number">3</span>)</span></span>;	<span class="comment">//使用vector</span></span><br><span class="line"><span class="built_in">CHECK_GL</span>(<span class="built_in">glReadPixels</span>(<span class="number">0</span>, <span class="number">0</span>, camera-&gt;m_nx,camera-&gt;m_ny, GL_RGB,GL_UNSIGNED_BYTE, pixels.<span class="built_in">data</span>()));	<span class="comment">//通过.data配合c语言操作</span></span><br><span class="line"><span class="comment">//vector离开作用域时，自动释放，.data获取的指针也会失效</span></span><br></pre></td></tr></table></figure>

<h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>C++ 中最神奇的运算符 <code>&#125;</code></p>
<p> <code>&#125;</code> 标志着一个语句块的结束，在这里，他会调用所有身处其中的对象的解构函数。比如这里的 <code>vector</code>，他的解构函数会释放动态数组的内存（即自动 delete）。</p>
<p><code>vector</code> 会在退出作用域时释放内存，这时候所有指向其中元素的指针，包括 <code>data()</code> 都会失效。因此如果你是在语句块内获取的 <code>data()</code> 指针，语句块外就无法访问了。</p>
<p>可见 <code>data()</code> 指针是对 <code>vector</code> 的一种引用，实际对象生命周期仍由 <code>vector</code> 类本身管理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        p = a.<span class="built_in">data</span>();</span><br><span class="line">        cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="comment">//离开作用域</span></span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//-1431446021	无效数</span></span><br></pre></td></tr></table></figure>

<h4 id="延续生命周期"><a href="#延续生命周期" class="headerlink" title="延续生命周期"></a>延续生命周期</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector&lt;int&gt; holder;//全局变量，main退出释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; holder;	<span class="comment">//与p生命周期相同</span></span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        p = a.<span class="built_in">data</span>();</span><br><span class="line">        cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        holder = std::<span class="built_in">move</span>(a);</span><br><span class="line">    &#125;<span class="comment">//离开作用域</span></span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>



<p>如果需要在一个语句块外仍然保持 data() 对数组的弱引用有效，可以把语句块内的 vector 对象移动到外面的一个 vector 对象上。vector 在移动时指针不会失效，例如：</p>
<p><code>a = move(b)</code></p>
<p>则会把 b 变成空数组，a 指向原来 b 所包含的元素数组，且地址不变。</p>
<p>之后即使不直接使用外面的那个临时对象 a，也可以继续通过 data() 指针来访问数据。</p>
<p>也可以移动到一个全局变量的 vector 对象。这样数组就会一直等到 main 退出了才释放。</p>
<ul>
<li>C++ 规定全局变量都会在进入 main 函数<strong>之前</strong>构造，main 函数返回之后解构</li>
</ul>
<h3 id="resize-和内存管理"><a href="#resize-和内存管理" class="headerlink" title="resize()和内存管理"></a><code>resize()</code>和内存管理</h3><h4 id="resize到更大尺寸会导致data失效"><a href="#resize到更大尺寸会导致data失效" class="headerlink" title="resize到更大尺寸会导致data失效"></a>resize到更大尺寸会导致data失效</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a.<span class="built_in">data</span>();</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">1024</span>);</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//-1431446021</span></span><br></pre></td></tr></table></figure>

<p>当 resize 的目标长度<strong>大于</strong>原有的容量时，就需要<strong>重新分配一段更大的连续内存</strong>，并把<strong>原数组长度的部分移动过去</strong>，多出来的部分则用 0 来填充。这就导致元素的地址会有所改变，从而过去 data 返回的指针以及所有的迭代器对象，都会失效。</p>
<h4 id="resize到更小尺寸不会导致data失效"><a href="#resize到更小尺寸不会导致data失效" class="headerlink" title="resize到更小尺寸不会导致data失效"></a>resize到更小尺寸不会导致data失效</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a.<span class="built_in">data</span>();</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>当 resize 的目标长度<strong>小于</strong>原有的容量时，不需要重新分配一段连续的内存也不会造成元素的移动（这个设计是为了性能考虑），所以指向元素的指针不会失效。他只是会把数组的长度标记为新长度，后面<strong>空闲出来那一段内存不会释放掉</strong>，继续留在那里，直到 vector 对象被解构。</p>
<p><strong>重新resize到原来也不会导致data失效</strong></p>
<ul>
<li>调用了 a.resize(2) 之后，数组的<strong>容量</strong>仍然是 5，因此重新扩容到 5 是不需要重新分配内存的，也就不会移动元素导致指针失效。</li>
</ul>
<h4 id="capacity-函数查询实际的最大容量"><a href="#capacity-函数查询实际的最大容量" class="headerlink" title="capacity()函数查询实际的最大容量"></a><code>capacity()</code>函数查询实际的最大容量</h4><p><code>size_t capacity() const noexcept;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 5/5</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 2/5</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 5/5</span></span><br><span class="line"><span class="comment">// 0x1f287929410 7/10</span></span><br></pre></td></tr></table></figure>

<p>可以用 capacity() 函数查询已经分配内存的大小，即<strong>最大容量</strong>。</p>
<p>而 size() 返回的其实是已经存储了数据的<strong>数组长度</strong>。</p>
<p>可以发现当 resize 指定的新<strong>长度</strong>一个超过原来的最大<strong>容量</strong>时时，就会重新分配一段更大<strong>容量</strong>的内存来存储数组，只有这时才会移动元素的位置（data 指针失效）。</p>
<h4 id="resize-的优化策略"><a href="#resize-的优化策略" class="headerlink" title="resize()的优化策略"></a><code>resize()</code>的优化策略</h4><p>注意这里 resize(7) 之后容量实际上扩充到了 10 而不是刚好 7，为什么？</p>
<p>因为标准库的设计者非常聪明，他料想到了你 resize(7) 以后可能还会来个 resize(8) 甚至 resize(9) 之类的。为了减少重复分配的次数，他有一个策略：当 resize 后的新尺寸变化较小时，则<strong>自动扩容至原尺寸的两倍</strong>。</p>
<p>这里我们的原大小是 5，所以 resize(7) 会扩充<strong>容量</strong>到 10，但是<strong>尺寸</strong>为 7。</p>
<ul>
<li><p>尺寸总是小于等于容量。</p>
</li>
<li><p>尺寸范围内都是已初始化的内存(零)。</p>
</li>
<li><p>寸到容量之间的范围是未初始化的。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 5/5</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 2/5</span></span><br><span class="line"><span class="comment">// 0x1f287924f80 5/5</span></span><br><span class="line"><span class="comment">// 0x1f287929410 12/12</span></span><br></pre></td></tr></table></figure>

<p>不过如果 <code>resize</code> 后的尺寸还超过了原先尺寸的两倍，就没有这个效果了。</p>
<p>也就是说 <code>resize(n)</code> 的逻辑是扩容至 <code>max(n, capacity * 2)</code>。</p>
<h4 id="reserve-预留一定容量，避免之后重复分配"><a href="#reserve-预留一定容量，避免之后重复分配" class="headerlink" title="reserve()预留一定容量，避免之后重复分配"></a><code>reserve()</code>预留一定容量，避免之后重复分配</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">reserve</span>(<span class="number">12</span>);	<span class="comment">//预留12</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// 0x1a8d4b9eb90 5/5</span></span><br><span class="line"><span class="comment">// 0x1a8d4b97440 5/12</span></span><br><span class="line"><span class="comment">// 0x1a8d4b97440 2/12</span></span><br><span class="line"><span class="comment">// 0x1a8d4b97440 5/12</span></span><br><span class="line"><span class="comment">// 0x1a8d4b97440 12/12</span></span><br></pre></td></tr></table></figure>

<p>内存分配是需要一定时间的。如果我们程序员能预料到数组最终的大小，可以用 <code>reserve</code> 函数<strong>预留</strong>一定的容量，这样之后就不会出现容量不足而需要动态扩容影响性能了。</p>
<p>例如这里我们一开始预留了 12 格容量，这样从 5 到 12 的时候就不必重新分配。此外，还要注意 <code>reserve</code> 时也会移动元素。</p>
<h4 id="shrink-t0-fit-释放多余的容量"><a href="#shrink-t0-fit-释放多余的容量" class="headerlink" title="shrink_t0_fit()释放多余的容量"></a><code>shrink_t0_fit()</code>释放多余的容量</h4><p>刚刚说过，当 <code>resize</code> 到一个更小的大小上时，多余的容量不会释放，而是继续保留。如担心内存告急可以用 <code>shrink_to_fit</code> 释放掉多余的容量，只保留刚好为 size() 大小的容量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// 0x1de1be5e750 5/5</span></span><br><span class="line"><span class="comment">// 0x1de1be573c0 12/12</span></span><br><span class="line"><span class="comment">// 0x1de1be573c0 4/12</span></span><br><span class="line"><span class="comment">// 0x1de1be5e750 4/4</span></span><br></pre></td></tr></table></figure>

<p><code>shrink_to_fit</code> 会重新分配一段更小内存，他同样是会把元素移动到新内存中的，因此迭代器和指针也会失效。</p>
<h3 id="一个小工具：mallochook"><a href="#一个小工具：mallochook" class="headerlink" title="一个小工具：mallochook"></a>一个小工具：mallochook</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/sjp38/mallochook/blob/master/mallochook.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __unix__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span> *(*<span class="type">malloc_t</span>)(<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">static</span> <span class="type">malloc_t</span> malloc_fn = (<span class="type">malloc_t</span>)<span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">malloc_fn</span>(size);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\033[32mmalloc(%zu) = %p\033[0m\n&quot;</span>, size, p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">free_t</span>)</span><span class="params">(<span class="type">void</span> *ptr)</span></span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">free_t</span> free_fn = (<span class="type">free_t</span>)<span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;free&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\033[31mfree(%p)\033[0m\n&quot;</span>, ptr);</span><br><span class="line">    <span class="built_in">free_fn</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了追踪所有的内存分配与释放，我们试着重写一下 malloc 和 free 函数。</p>
<p>这样当 vector 容器分配或是释放内存的时候，我们就能轻松看到。</p>
<p>不过这个只能 Linux 系统可以用哦</p>
<h3 id="puch-back-的问题"><a href="#puch-back-的问题" class="headerlink" title="puch_back()的问题"></a><code>puch_back()</code>的问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mallochook.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        a.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// malloc(72704) = 0xaaab167f12a0</span></span><br><span class="line"><span class="comment">// malloc(4) = 0xaaab16802eb0</span></span><br><span class="line"><span class="comment">// malloc(8) = 0xaaab16802ed0</span></span><br><span class="line"><span class="comment">// free(0xaaab16802eb0)</span></span><br><span class="line"><span class="comment">// malloc(16) = 0xaaab16802eb0</span></span><br><span class="line"><span class="comment">// free(0xaaab16802ed0)</span></span><br><span class="line"><span class="comment">// malloc(32) = 0xaaab16802ef0</span></span><br><span class="line"><span class="comment">// free(0xaaab16802eb0)</span></span><br><span class="line"><span class="comment">// malloc(64) = 0xaaab16802f20</span></span><br><span class="line"><span class="comment">// free(0xaaab16802ef0)</span></span><br><span class="line"><span class="comment">// malloc(128) = 0xaaab16802f70</span></span><br><span class="line"><span class="comment">// free(0xaaab16802f20)</span></span><br><span class="line"><span class="comment">// malloc(256) = 0xaaab16803000</span></span><br><span class="line"><span class="comment">// free(0xaaab16802f70)</span></span><br><span class="line"><span class="comment">// malloc(512) = 0xaaab16803110</span></span><br><span class="line"><span class="comment">// free(0xaaab16803000)</span></span><br><span class="line"><span class="comment">// malloc(1024) = 0xaaab16803320</span></span><br><span class="line"><span class="comment">// &#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99&#125;</span></span><br><span class="line"><span class="comment">// free(0xaaab16803110)</span></span><br></pre></td></tr></table></figure>

<p>由于不知道你究竟会推入多少个元素，vector 的初始容量是零，而 push_back 和 resize 一样，每次遇到容量不足时，都会扩容两倍，例如上面的输出。</p>
<p>这也体现了<strong>实际容量</strong><code>(capacity)</code>和数组大小<code>(size)</code>分离的好处，如果死板地让分配的内存容量始终等于当前数组大小（很多同学都号称自己实现过 <code>vector</code>，都是这种写法），那么如果要用 push_back 推入 n 个元素，就需要重新分配内存 n 次，移动元素 n(n+1)&#x2F;2 次。</p>
<p>而像标准库这样允许数组大小和实际容量不同，这样 push_back 在容量不足的时候就可以一次性扩容两倍，只需重新分配 logn 次，移动元素 2n-1 次。</p>
<h4 id="解决：reserve"><a href="#解决：reserve" class="headerlink" title="解决：reserve()"></a>解决：<code>reserve()</code></h4><p>因此，如果你早就知道要推入元素的数量，可以调用 reserve 函数先预留那么多的<strong>容量</strong>，等待接下来的推入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mallochook.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    a.<span class="built_in">reserve</span>(<span class="number">100</span>); <span class="comment">// 预留空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        a.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// malloc(72704) = 0xaaaaf6e992a0</span></span><br><span class="line"><span class="comment">// malloc(400) = 0xaaaaf6eaaeb0</span></span><br><span class="line"><span class="comment">// malloc(1024) = 0xaaaaf6eab050</span></span><br><span class="line"><span class="comment">// &#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99&#125;</span></span><br><span class="line"><span class="comment">// free(0xaaaaf6eaaeb0)</span></span><br></pre></td></tr></table></figure>

<p>这样之后 push_back 时，就不会一次次地扩容两倍慢慢成长到 128，避免重新分配内存和移动元素，更高效。</p>
<p>比如这里我们可以提前知道循环会执行 100 次，因此 reserve(100) 就可以了。</p>
<p>可以看到只有一次 malloc(400)，之后那次 malloc(1024) 是 cout 造成的，不必在意。</p>
<h3 id="clear-的问题"><a href="#clear-的问题" class="headerlink" title="clear()的问题"></a><code>clear()</code>的问题</h3><p>刚刚说过，<code>clear</code> 相当于 <code>resize(0)</code>，所以他也不会实际释放掉内存，**容量(capacity)<strong>还是摆在那里，clear 仅仅只是把</strong>数组大小(size)**标记为 0 而已。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mallochook.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before clear, capacity=&quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after clear, capacity=&quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// malloc(72704) = 0xaaaae7f4d2a0</span></span><br><span class="line"><span class="comment">// malloc(16) = 0xaaaae7f5eeb0</span></span><br><span class="line"><span class="comment">// malloc(1024) = 0xaaaae7f5eed0</span></span><br><span class="line"><span class="comment">// before clear, capacity=4</span></span><br><span class="line"><span class="comment">// after clear, capacity=4</span></span><br><span class="line"><span class="comment">// free(0xaaaae7f5eeb0)</span></span><br></pre></td></tr></table></figure>

<p>这可能导致在低端平台上内存告急，这是因为尽管你已经 clear 掉 vector 了而实际容量还在并没有释放。</p>
<h4 id="解决：shrink-to-fit"><a href="#解决：shrink-to-fit" class="headerlink" title="解决：shrink_to_fit()"></a>解决：<code>shrink_to_fit()</code></h4><p>要真正释放掉内存，可以在 clear 之后再调用 shrink_to_fit，这样才会让容量也变成 0（这时 vector 的 data 会返回 nullptr）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mallochook.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before clear, capacity=&quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">clear</span>();</span><br><span class="line">    a.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after clear, capacity=&quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// malloc(72704) = 0xaaab077092a0</span></span><br><span class="line"><span class="comment">// malloc(16) = 0xaaab0771aeb0</span></span><br><span class="line"><span class="comment">// malloc(1024) = 0xaaab0771aed0</span></span><br><span class="line"><span class="comment">// before clear, capacity=4</span></span><br><span class="line"><span class="comment">// free(0xaaab0771aeb0)</span></span><br><span class="line"><span class="comment">// after clear, capacity=0</span></span><br></pre></td></tr></table></figure>

<p>当然，vector 对象解构时也会彻底释放内存，这个不用操心。clear 配合 shrink_to_fit 只是提前释放而已。</p>
<h2 id="迭代器入门"><a href="#迭代器入门" class="headerlink" title="迭代器入门"></a>迭代器入门</h2><h3 id="迭代器的引入"><a href="#迭代器的引入" class="headerlink" title="迭代器的引入"></a>迭代器的引入</h3><h4 id="迭代器结构的出现"><a href="#迭代器结构的出现" class="headerlink" title="迭代器结构的出现"></a>迭代器结构的出现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">char</span>&gt; <span class="type">const</span> &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们都知道，可以使用一个函数来封装打印操作，但是这样的缺点是它智能打印<code>vector</code>类型，没法打印<code>string</code>类型，要想支持<code>string</code>只能再实现另一个<code>print</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *a, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(a.<span class="built_in">data</span>(), a.<span class="built_in">size</span>());</span><br><span class="line">    string b = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(b.<span class="built_in">data</span>(), b.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 <code>vector</code> 和 <code>string</code> 的底层都是连续的稠密数组，他们都有 <code>data()</code> 和 <code>size()</code> 函数。</p>
<p>因此可改用<strong>首地址指针</strong>和<strong>数组长度</strong>做参数：</p>
<p><code>print(char const *a, size_t n);</code></p>
<p>这样 <code>print</code> 在无需知道容器具体类型的情况下，只用最简单的接口（首地址指针）就完成了遍历和打印的操作。</p>
<p>使用<strong>指针</strong>和<strong>长度</strong>做接口的好处是，可以通过给指针加减运算，选择其中一部分连续的元素来打印，而不一定全部打印出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *a, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(a.<span class="built_in">data</span>(), a.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如这里我们选择打印<strong>前三个元素</strong>（去掉了最后一个元素，但不必用 <code>pop_back</code> 修改数组，只要传参数的时候修改一下<strong>长度</strong> 部分即可）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *a, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(a.<span class="built_in">data</span>() + <span class="number">1</span>, a.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择打印<strong>后三个元素</strong>（去掉了第一个元素，但不必用 <code>erase</code> 修改数组，只要传参数的时候同时修改<strong>指针</strong>和<strong>长度</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *begptr, <span class="type">char</span> <span class="type">const</span> *endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="type">const</span> *ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="type">char</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *begptr = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *endptr = a.<span class="built_in">data</span>() + a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">print</span>(begptr, endptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们发现，<strong>首地址指针</strong>和<strong>数组长度</strong>看起来不太对称。</p>
<p><code>print(char const *begptr, size_t size);</code></p>
<p>不妨改用<strong>首地址指针</strong>和<strong>尾地址指针</strong>如何？</p>
<p><code>print(char const *begptr, size_t endptr);</code></p>
<p>注意看，我们在 print 里也不是用<strong>数组下标</strong>去迭代，而是用<strong>指针</strong>作为迭代变量了。</p>
<h4 id="首指针-尾指针"><a href="#首指针-尾指针" class="headerlink" title="首指针 + 尾指针"></a>首指针 + 尾指针</h4><p>改用<strong>首地址指针</strong>和<strong>尾地址指针</strong>以后，要特别注意一点：<strong>尾地址指针</strong>实际上是指向末尾元素再往后后一个元素的指针！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *begptr, <span class="type">char</span> <span class="type">const</span> *endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="type">const</span> *ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="type">char</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *begptr = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *endptr = a.<span class="built_in">data</span>() + a.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*begptr = &quot;</span> &lt;&lt; *begptr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*endptr = &quot;</span> &lt;&lt; *endptr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*(endptr - 1) = &quot;</span> &lt;&lt; *(endptr<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(begptr, endptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// *begptr = h</span></span><br><span class="line"><span class="comment">// *endptr = ?	随机值</span></span><br><span class="line"><span class="comment">// *(endptr - 1) = l</span></span><br><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="comment">// j</span></span><br><span class="line"><span class="comment">// k</span></span><br><span class="line"><span class="comment">// l</span></span><br></pre></td></tr></table></figure>

<p>也就是说<strong>尾地址指针</strong>所指向的地方是无效的内存 <code>a + a.size()</code>，<strong>尾地址指针减1</strong>才是真正的末尾元素指针 <code>a + a.size() - 1</code>。</p>
<p>为什么要这样设计？因为如果用 a + <code>a.size() - 1</code> 也就是 <code>&amp;a.back()</code> 作为尾地址指针，将无法表示<strong>数组长度为</strong> <strong>0</strong> 的情况。</p>
<p>而让<strong>尾地址指针</strong>往后移动一格的设计，使得数组长度为 0 就是 <code>begptr == endptr</code> 的情况，非常容易判断。</p>
<p>更方便的是你可以通过指针的减法运算： endptr - begptr 来算出数组的长度！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *begptr, <span class="type">char</span> <span class="type">const</span> *endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> <span class="type">const</span> *ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="type">char</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *begptr = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *endptr = a.<span class="built_in">data</span>() + a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> size = endptr - begptr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;begptr - endptr = &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(begptr, endptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// begptr - endptr = 4</span></span><br><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="comment">// j</span></span><br><span class="line"><span class="comment">// k</span></span><br><span class="line"><span class="comment">// l</span></span><br></pre></td></tr></table></figure>

<p>for 循环里也很容易写，判断是否继续循环的条件为 <code>ptr != endptr</code> 就行了。</p>
<h4 id="模板实现"><a href="#模板实现" class="headerlink" title="模板实现"></a>模板实现</h4><p>最后，我们可以让<strong>首指针</strong>和<strong>尾指针</strong>声明为模板参数，这样不论指针是什么类型，都可以使用 print 这个模板函数来打印。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Ptr begptr, Ptr endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Ptr ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *abegptr = a.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *aendptr = a.<span class="built_in">data</span>() + a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">print</span>(abegptr, aendptr);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> *bbegptr = b.<span class="built_in">data</span>();</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> *bendptr = b.<span class="built_in">data</span>() + b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">print</span>(bbegptr, bendptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="comment">// j</span></span><br><span class="line"><span class="comment">// k</span></span><br><span class="line"><span class="comment">// l</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h4 id="不连续内存的容器"><a href="#不连续内存的容器" class="headerlink" title="不连续内存的容器"></a>不连续内存的容器</h4><p><strong>首指针</strong>和<strong>尾指针</strong>的组合的确能胜任 vector 这种连续数组，但是对于 list 这种不连续的内存的容器就没辙了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Ptr begptr, Ptr endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Ptr ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *begptr = a.<span class="built_in">data</span>();	<span class="comment">//No member named &#x27;data&#x27;</span></span><br><span class="line">    <span class="type">char</span> <span class="type">const</span> *endptr = a.data + a.<span class="built_in">size</span>();	<span class="comment">// No member named &#x27;data&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(begptr, endptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没错，list 没有 data() 这个成员函数，因为他根本就不连续。</p>
<h4 id="首迭代器-尾迭代器"><a href="#首迭代器-尾迭代器" class="headerlink" title="首迭代器 + 尾迭代器"></a>首迭代器 + 尾迭代器</h4><p>然而 list 却提供了 begin() 和 end() 函数，他们会返回两个 list<char>::iterator 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Ptr begptr, Ptr endptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Ptr ptr = begptr; ptr != endptr; ptr++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> value = *ptr;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list&lt;<span class="type">char</span>&gt; a = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    list&lt;<span class="type">char</span>&gt;::iterator begptr = a.<span class="built_in">begin</span>();</span><br><span class="line">    list&lt;<span class="type">char</span>&gt;::iterator endptr = a.<span class="built_in">end</span>();</span><br><span class="line">    <span class="built_in">print</span>(begptr, endptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="comment">// j</span></span><br><span class="line"><span class="comment">// k</span></span><br><span class="line"><span class="comment">// l</span></span><br></pre></td></tr></table></figure>

<p>这个 <code>list&lt;char&gt;::iterator</code> 是一个特殊定义过的类型，其具有 <code>!=</code> 和 <code>++</code> 以及 <code>*</code> 这些<code>**</code><strong>运算符的重载</strong>。所以用起来就像普通的指针一样。而这些运算符重载，却会<strong>把<code>++</code>对应到链表的<code>curr=curr-&gt;next</code>上</strong>。</p>
<p>这样一个用起来就像普通的指针，但内部却通过运算符重载适配不同容器的特殊类，就是<strong>迭代器(iterator)</strong>，迭代器是 STL 中<strong>容器</strong>和<strong>算法</strong>之间的桥梁。</p>
<p>如果让我们来写 list 容器和他的迭代器，他的内部具体实现可能是这样的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        T value;</span><br><span class="line">        Node *next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">        Node *curr;</span><br><span class="line"></span><br><span class="line">        Iterator &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> curr-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(Iterator <span class="type">const</span> &amp;that) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> curr != that.curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node *head;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;head&#125;; &#125;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        T value;</span><br><span class="line">        Node *next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">        Node *curr;</span><br><span class="line"></span><br><span class="line">        Iterator &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">            Iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>++();</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> curr-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(Iterator <span class="type">const</span> &amp;that) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> curr != that.curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node *head;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;head&#125;; &#125;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;head + size&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iterate_over_list</span><span class="params">(List&lt;<span class="type">int</span>&gt; <span class="type">const</span> &amp;list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> curr = list.head; curr != <span class="literal">nullptr</span>; curr = curr-&gt;next) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器的这些运算符，都是约定俗成的，其根本目的在于模仿指针的行为，方便来自 C 语言的程序员快速上手掌握 C++ 标准库。</p>
<p>虽然你也可以用直观的函数名 <code>advance()</code> 代替 <code>++</code>，用 deref() 代替 <code>*</code>，equal_to() 代替 <code>==</code>。但是模仿指针行为的这些运算符，已然成为了 C++ 事实上的标准，而且也非常简洁明了。</p>
<p>因此所有的用户和库，都会按照这套运算符标准来实现和使用迭代器，建立起了沟通的桥梁，节省了各自创立一套规范的成本。</p>
<h4 id="迭代器中-的前置和后置"><a href="#迭代器中-的前置和后置" class="headerlink" title="迭代器中++的前置和后置"></a>迭代器中<code>++</code>的前置和后置</h4><p>迭代器的自增运算符分为 <code>++p</code> 和 p++ 两种写法。他们都会产生 <code>p = p + 1</code> 的效果，但是有一个细微的区别，就是他们<strong>被作为表达式时的返回值</strong>。</p>
<ul>
<li><p><strong>前置自增 <code>++p</code></strong>：此运算符会先将迭代器<code>p</code>自增，然后返回自增后的迭代器本身。由于返回的是左值引用，因此可以继续进行自增操作，例如<code>++++p</code>。</p>
</li>
<li><p><strong>后置自增 <code>p++</code></strong>：此运算符会先返回自增前的迭代器值，然后再执行自增。返回值是一个右值，不能被修改。</p>
</li>
</ul>
<p>正因如此，后置自增需要先保存旧的迭代器，然后自增自己，再返回旧迭代器，可能<strong>会比较低效</strong>。</p>
<p>在 C++ 中我们推荐尽可能地多用前置自增 ++p。</p>
<ul>
<li><p>在运算符重载上，沙雕的C++ 标准委员会规定，<code>operator++(int)</code> 这个重载是后置自增 <code>p++</code>，不带任何参数的<code>operator++()</code> 这个重载是前置自增，之所以这样是因为同名函数只能通过参数列表类型来区分，这个 int 类型参数没有任何实际意义，只是为了区分不同的重载……<strong>编译器会在p++的时候自动改成调用p.operator++(0)</strong>，这个0只是为了区分重载</p>
</li>
<li><pre><code class="language-cpp">Iterator &amp;operator++()&#123;
    curr = curr-&gt;next;
    return *this;
&#125;
Iterator operator++(int)&#123;
    Iterator tmp = *this;
    this-&gt;operator++();
    return tmp;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## vector容器中的迭代器</span><br><span class="line"></span><br><span class="line">#### `begin()`和`end()`函数</span><br><span class="line"></span><br><span class="line">`begin()` 可以获取指向第一个元素所在位置的**迭代器**。</span><br><span class="line"></span><br><span class="line">`end()` 可以获取指向最后一个元素下一个位置的**迭代器**。</span><br><span class="line"></span><br><span class="line">迭代器的作用类似于一个位置标记符。</span><br><span class="line"></span><br><span class="line">虽然对于 `vector` 来说只需要下标（index）就能标记位置了，例如 Python 中也是通过 0 表示第一个元素，-1 表示最后一个元素：`a[0] a[1] a[-1]`</span><br><span class="line"></span><br><span class="line">而 C++ 的特色就是采用了迭代器（iterator）来标记位置，他实际上是一个指针，这样的好处是：不需要指定原来的容器本身，就能知道指定的位置。</span><br><span class="line"></span><br><span class="line">一对迭代器 `begin` 和 `end` 就标记了一个区间（range）。区间可以是一个容器的全部，例如 `&#123;a.begin(), a.end()&#125;` 区间；也可以是一个容器的部分，例如 `&#123;a.begin() + 1, a.end() - 1&#125;` 相当于去头去尾后的列表，相当于 Python 中的 `a[1:-1]`。</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;printer.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; a = &#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;::iterator b = a.begin();</span><br><span class="line">    vector&lt;int&gt;::iterator e = a.end();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*b = &quot; &lt;&lt; *b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*(b + 1) = &quot; &lt;&lt; *(b + 1) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*(b + 2) = &quot; &lt;&lt; *(b + 2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*(e - 2) = &quot; &lt;&lt; *(e - 2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*(e - 1) = &quot; &lt;&lt; *(e - 1) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*e = &quot; &lt;&lt; *e &lt;&lt; endl;	//直接访问end是一个无效地址</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 输出：</span><br><span class="line">// a = &#123;1,2,3,4,5,6&#125;</span><br><span class="line">// *b = 1</span><br><span class="line">// *(b + 1) = 2</span><br><span class="line">// *(b + 2) = 3</span><br><span class="line">// *(e - 2) = 5</span><br><span class="line">// *(e - 1) = 6</span><br><span class="line">// *e = -450617339	随机数</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><code>begin</code> 可以获取指向<strong>第一个元素所在位置</strong>的迭代器。可以通过 <code>*a.begin()</code> 来访问第一个元素。</p>
<p>迭代器支持加法运算，例如 <code>*(a.begin() + 1)</code> 就是访问数组的第二个元素了，和 a[1] 等价。</p>
<p><code>end</code> 可以获取指向<strong>最后一个元素下一个位置</strong>的迭代器。也就是说 <code>end</code> 指向的位置是不可用的！如需访问最后一个元素必须用 <code>*(a.end() - 1)</code> 才行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2024/10/21/CPP/%E6%A0%87%E5%87%86%E5%BA%93/%E4%BA%8C%E3%80%81vector%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%85%A5%E9%97%A8/image-20241022221652364.png" alt="image-20241022221652364"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator b = a.<span class="built_in">begin</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator e = a.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b[0] = &quot;</span> &lt;&lt; b[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b[1] = &quot;</span> &lt;&lt; b[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b[2] = &quot;</span> &lt;&lt; b[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;e[-2] = &quot;</span> &lt;&lt; e[<span class="number">-2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;e[-1] = &quot;</span> &lt;&lt; e[<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;e[0] = &quot;</span> &lt;&lt; e[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// b[0] = 1</span></span><br><span class="line"><span class="comment">// b[1] = 2</span></span><br><span class="line"><span class="comment">// b[2] = 3</span></span><br><span class="line"><span class="comment">// e[-2] = 5</span></span><br><span class="line"><span class="comment">// e[-1] = 6</span></span><br><span class="line"><span class="comment">// e[0] = -1739380936</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>冷知识</strong>，迭代器实际上还可以用 <code>[]</code> 运算符访问。</p>
<p>例如这里的 <code>b[i]</code> 就和 <code>*(b + i)</code> 等价。</p>
<p>不过只有 vector 这种连续的可随机访问容器的迭代器有 <code>+</code> 和 <code>[]</code> 运算符，对于 list 则只有 <code>*</code> 和 +<code>+</code> 和 <code>--</code> 运算符可以用，这是迭代器的两个分类，详见下一章。</p>
<p>自此，迭代器对象和容器本身的主要区别就在于：</p>
<p>迭代器不掌握生命周期，从而迭代器的拷贝是平凡的<strong>浅拷贝</strong>，方便传参。但也带来了缺点，因为迭代器是一个对原容器的弱引用，如果原容器解构或发生内存重分配，迭代器就会失效。</p>
<h4 id="insert-函数"><a href="#insert-函数" class="headerlink" title="insert()函数"></a><code>insert()</code>函数</h4><h5 id="头部插入"><a href="#头部插入" class="headerlink" title="头部插入"></a>头部插入</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//b = &#123;233,1,2,3,4,5,6&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们知道 <code>push_back</code> 可以往尾部插入数据，那么如何往<strong>头部</strong>插入数据呢？用<code>insert</code>函数，他的第一个参数是要插入的位置（用迭代器表示），第二个参数则是要插入的值。</p>
<p>注意这个函数的复杂度是 O(n)，n 是从<strong>插入位置<code>pos</code></strong> 到<strong>数组末尾<code>end</code></strong> 的距离。没错，他会插入位置后方的元素整体向后移动一格，是比较低效的，因此为了高效，我们尽量只往尾部插入元素。如果需要高效的头部插入，可以考虑用 <code>deque</code> 容器，他有高效的 <code>push_front</code> 函数替代。</p>
<p><code>insert</code> 在容量不足时，同样会造成重新分配以求扩容，会移动其中所有元素，这时所有之前保存的迭代器都会失效。</p>
<h5 id="特定位置插入"><a href="#特定位置插入" class="headerlink" title="特定位置插入"></a>特定位置插入</h5><p><code>iterator insert(const_iterator pos, int const &amp;val);</code></p>
<p><code>iterator insert(const_iterator pos, int &amp;&amp;val); // C++11</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>() + <span class="number">3</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">//  = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,233,4,5,6&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果要插入到一个特定位置，可以用迭代器的加法来获取某一位置的迭代器。</p>
<p>例如 <code>a.begin() + 3</code> 就会指向第三个元素，那么用这个作为 <code>insert</code> 的参数就会把 <code>233</code> 这个值插到第三个元素的位置之前。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入位置是倒数第二个</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">end</span>(), <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,233,5,6&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>a.begin()</code> 可以插入到开头位置。</p>
<p><code>a.begin() + 1</code> 可以插入到第二个元素位置。</p>
<p><code>a.end()</code> 可以插入到最末尾（append）。</p>
<p><code>a.end() - 1</code> 则是插入到倒数第一个元素前。</p>
<p><code>end()</code> 迭代器的减法和是 Python 中负数作为下标的情况很像的，不过 C++ 更加明确是从 end 开始往前数的。</p>
<h5 id="重复插入多个相同的值"><a href="#重复插入多个相同的值" class="headerlink" title="重复插入多个相同的值"></a>重复插入多个相同的值</h5><p><code>iterator insert(const_iterator pos, size_t n, int const &amp;val);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), <span class="number">4</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;233,233,233,233,1,2,3,4,,5,6&#125;</span></span><br></pre></td></tr></table></figure>

<p>insert 还有一个特殊的功能，就是他可以插入一个元素很多遍！只需多指定一个参数来表示插入多少遍，语法如下：</p>
<p><code>a.insert(插入位置, 重复多少次, 插入的值);</code></p>
<ul>
<li>你可能会担心，刚刚不是说在头部 insert 是 O(n) 复杂度嘛？那如果再重复 n 次岂不是 O(n²) 复杂度了？</li>
<li>当然不会，<code>insert</code> 的这个重载会一次性批量让 <code>pos</code> 之后的元素移动 n 格，不存在反复移动 1 格的情况，最坏复杂度仍然是 O(n)。如果你自己写个 for 循环反复调 <code>insert</code> 那的确是会 O(n²) 了，这就是为什么 <code>insert</code> 提供这个高效的重载专门负责重复插入的操作。</li>
</ul>
<h5 id="直接插入一个初始化列表"><a href="#直接插入一个初始化列表" class="headerlink" title="直接插入一个初始化列表"></a>直接插入一个初始化列表</h5><p><code>iterator insert(const_iterator pos, initializer_list&lt;int&gt; lst);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;233,666,985,211,1,2,3,4,5,6&#125;</span></span><br></pre></td></tr></table></figure>

<p>insert 还可以直接插入一个 <code>&#123;&#125;</code> 的列表！</p>
<p>这个花括号 <code>&#123;&#125;</code> 形成的列表就是传说中的<strong>初始化列表(initializer-list)</strong>，是 C++11 新增的功能，例如这里这个列表的类型是 <code>std::initializer_list&lt;int&gt;</code>。</p>
<p><code>a.insert(插入位置, &#123;插入值1, 插入值2, ...&#125;);</code></p>
<p>这个的最坏复杂度同样是 O(n) 的，并且因为其内部预先知道了要插入列表的长度，会一次性完成扩容，比重复调用 push_back 重复扩容要高效很多。</p>
<h5 id="直接插入另一个vector"><a href="#直接插入另一个vector" class="headerlink" title="直接插入另一个vector"></a>直接插入另一个vector</h5><p><code>iterator insert(const_iterator pos, initializer_list&lt;int&gt; lst);</code></p>
<p>能否传入一个vector作为参数呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), b); <span class="comment">//直接传入vector对象</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// test.cpp: In function ‘int main()’:</span></span><br><span class="line"><span class="comment">// test.cpp:12:13: error: no matching function for call to ‘std::vector&lt;int&gt;::insert(std::vector&lt;int&gt;::iterator, std::vector&lt;int&gt;&amp;)’</span></span><br><span class="line"><span class="comment">//    12 |     a.insert(a.begin(), b); //直接传入vector对象</span></span><br></pre></td></tr></table></figure>

<p>不可以，因为<code>vector</code>和<code>initializer_list</code>不是同一个类型。</p>
<p>那要如何插入另一个数组，或者说把a和b两个数组进行合并？</p>
<p><strong>通过迭代器</strong></p>
<p><code>template &lt;class It&gt; // 这里 It 可以是其他容器的迭代器类型</code></p>
<p><code>iterator insert(const_iterator pos, It beg, It end);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());    <span class="comment">//传入区间</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = 1 2 3 4 5 6</span></span><br><span class="line"><span class="comment">//b = 233 666 985 211</span></span><br><span class="line"><span class="comment">//a = 233 666 985 211 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<p>记得 C++ 的迭代器思想是，<strong>容器</strong>和<strong>算法</strong>之间的交互不是通过容器对象本身，而是他的迭代器，因此 <code>insert</code> 设计时就决心不支持直接接受 <code>vector</code> 作参数，而是接受他的两个迭代器组成的区间！好处有：</p>
<ol>
<li><p>可以批量插入从来自另一个不同类型的容器，例如 list<int>，只要元素类型相等，且符合迭代器规范。</p>
</li>
<li><p>我可以自由选择对方容器的一个子区间（通过迭代器加减法）内的元素来插入，而不是死板的只能全部插入。</p>
</li>
</ol>
<p>刚才 <code>a.insert(a.begin(), b.begin(), b.end())</code> 会把 b 插入在原先 a 元素之前，相当于Python的 a &#x3D; b + a。</p>
<p>可以改用 <code>a.insert(a.end(), b.begin(), b.end())</code> 把 b 插入到 a 元素之后，相当于Python的 <code>a += b</code>，这样性能更好（只要容量足够就无需移动 a 的全部元素）。</p>
<p>当然也可以 <code>a.insert(a.begin() + 3, b.begin(), b.end())</code> 这样只插入到指定位置中间，Python似乎没有这个操作。</p>
<h5 id="数据源可是是不同类型"><a href="#数据源可是是不同类型" class="headerlink" title="数据源可是是不同类型"></a>数据源可是是不同类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6,233,666,985,211&#125;</span></span><br></pre></td></tr></table></figure>

<p>对方容器也可以是<strong>不同类型</strong>的，最底线的要求是只要他的迭代器有 <code>++</code> 和 <code>*</code> 运算符即可。</p>
<p>例如上面的 <code>list&lt;int&gt;::iterator</code> 就符合需求。</p>
<p><strong>甚至可以是一个c语言风格的数组</strong></p>
<p>c++11新增两个函数：</p>
<p><code>template &lt;class T&gt; auto begin(T &amp;&amp;t);</code></p>
<p><code>template &lt;class T&gt; auto end(T &amp;&amp;t);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">end</span>(), std::<span class="built_in">begin</span>(b), std::<span class="built_in">end</span>(b));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6,233,666,985,211&#125;</span></span><br></pre></td></tr></table></figure>

<p>因为 C 语言类型没有办法加成员函数 begin 和 end，可以用 <code>std::begin</code> 和 std::end 这两个全局函数代替，当然如果用了 <code>using namespace std</code> 时也可以不写 std:: 前缀。</p>
<p>这两个函数会对于具有 <code>begin</code> 和 <code>end</code> 成员函数的容器会直接调用，对于 C 语言数组则被特化为返回 <code>b</code> 和 <code>b + sizeof(b)/sizeof(b[0])</code>。</p>
<h4 id="构造函数也接受迭代器"><a href="#构造函数也接受迭代器" class="headerlink" title="构造函数也接受迭代器"></a>构造函数也接受迭代器</h4><p><code>template &lt;class It&gt;  // 这里 It 可以是其他容器的迭代器类型</code></p>
<p><code>explicit vector(It beg, It end);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(std::begin(b), std::end(b))</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;233,666,985.211&#125;</span></span><br></pre></td></tr></table></figure>

<p>vector 容器的构造函数也接受一对迭代器做参数，来初始化其中的元素。同样可以是不同容器的迭代器对象，只要具有 <code>++</code> 和 <code>*</code> 就行了。</p>
<h4 id="assign-函数"><a href="#assign-函数" class="headerlink" title="assign()函数"></a><code>assign()</code>函数</h4><p>重新分配vector中的值</p>
<p><code>template &lt;class It&gt; // 这里 It 可以是其他容器的迭代器类型</code></p>
<p><code>void assign(It beg, It end);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;;</span><br><span class="line">    a.<span class="built_in">assign</span>(std::<span class="built_in">begin</span>(b),std::<span class="built_in">end</span>(b));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;233,666,985,211&#125;</span></span><br></pre></td></tr></table></figure>

<p>除了构造函数外，<code>assign</code> 这个成员函数也能在后期把元素覆盖进去。和 <code>insert</code> 不同的是，他会把旧有的数组完全覆盖掉，变成一个新的数组。（清空原来的值，放入新值，注意此时不会重新分配内存）</p>
<p><code>a.assign(beg, end)</code> 基本和 <code>a = vector&lt;int&gt;(beg, end)</code> 等价，唯一的区别是后者会重新分配内存，而前者会保留原来的容量不会释放掉。</p>
<p><code>assign</code> 还有一个<code>重载</code>，可以把 <code>vector</code> 批量填满一个特定的值，重复的次数（长度）也是参数里指定。</p>
<p><code>void assign(size_t n, int const &amp;val);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">assign</span>(<span class="number">4</span>, <span class="number">233</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//a = &#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="comment">//a = &#123;233, 233, 233, 233&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>a.assign(n, val)</code> 基本和 <code>a = vector&lt;int&gt;(n, val)</code> 等价，唯一的区别是后者会重新分配内存，而前者会保留原来的容量。</p>
<p>assign 还可以直接接受一个初始化列表作为参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">assign</span>(&#123;<span class="number">233</span>, <span class="number">666</span>, <span class="number">985</span>, <span class="number">211</span>&#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a = &#123;<span class="number">996</span>, <span class="number">007</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.capacity() = &quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    a = vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">996</span>, <span class="number">007</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.capacity() = &quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;233,666,985,211&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;996,7&#125;</span></span><br><span class="line"><span class="comment">// a.capacity() = 6</span></span><br><span class="line"><span class="comment">// a.capacity() = 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>a.assign(&#123;x, y, ...&#125;)</code> 和 <code>a = &#123;x, y, ...&#125;</code> 完全等价，都会保留原来的容量。而和 <code>a = vector&lt;int&gt;&#123;x, y, ...&#125;</code> 就不等价，这个会重新分配内存。</p>
<h4 id="erase-函数"><a href="#erase-函数" class="headerlink" title="erase()函数"></a><code>erase()</code>函数</h4><h5 id="指定位置"><a href="#指定位置" class="headerlink" title="指定位置"></a>指定位置</h5><p>erase 函数可以删除指定位置的一个元素（通过迭代器指定）。</p>
<p><code>iterator erase(const_iterator pos);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">erase</span>(a.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,5&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>a.erase(a.begin())</code> 就是删除第一个元素（相当于 pop_front）。</p>
<p><code>a.erase(a.end() - 1)</code> 就是删除最后一个元素（相当于 pop_back）。</p>
<p><code>a.erase(a.begin() + 2)</code> 就是删除第三个元素。</p>
<p>a.erase(a.end() - 2) 就是删除倒数第二个元素。</p>
<p>erase 的复杂度最坏情况是删除第一个元素 O(n)。如果删的是最后一个元素则复杂度为 O(1)。</p>
<p>这是因为 erase 会移动 pos 之后的那些元素。</p>
<h5 id="指定区间"><a href="#指定区间" class="headerlink" title="指定区间"></a>指定区间</h5><p>erase 也可以指定两个迭代器作为参数，表示把这个区间内的对象都删除。</p>
<p>iterator erase(const_iterator beg, const_iterator end);</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printer.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">begin</span>() + <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// a = &#123;1,2,3,4,5,6&#125;</span></span><br><span class="line"><span class="comment">// a = &#123;1,4,5,6&#125;</span></span><br></pre></td></tr></table></figure>

<p>比如这里 <code>a.erase(a.begin() + 1, a.begin() + 3)</code> 就删除了 a 的第二个和第三个元素，相当于Python的 <code>del a[1:3]</code>，注意 C++ 的 insert 和 erase 都是就地操作的。</p>
<p>例如：<code>a.erase(a.begin() + n, a.end())</code> 就和 <code>a.resize(n)</code> 等价，前提是**<code>n小于a.size()</code>**。</p>
<p>批量删除的最坏复杂度依然是 O(n) 的，不用担心。</p>
<p>不过这里两个作为 erase 参数的迭代器<strong>必须是自己这个对象的迭代器</strong>，不能是其他容器的，这点和 insert 不一样。</p>
<p>他返回删除后<code>最后一个元素之后</code>那个位置的迭代器。</p>
</article><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/21/CPP/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&amp;%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">全面理解STL-std::string用法指南&amp;源码刨析</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/21/CPP/%E6%A0%87%E5%87%86%E5%BA%93/%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">全面理解STL-前言</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/10/21/CPP/%E6%A0%87%E5%87%86%E5%BA%93/%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80/" title="全面理解STL-前言"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-10-21</div><div class="title">全面理解STL-前言</div></div></a></div><div><a href="/2024/10/23/CPP/%E6%A0%87%E5%87%86%E5%BA%93/%E4%B8%89%E3%80%81set%E7%B3%BB%E5%88%97%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB/" title="全面理解STL-set系列容器与迭代器分类"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-10-23</div><div class="title">全面理解STL-set系列容器与迭代器分类</div></div></a></div><div><a href="/2024/10/21/CPP/%E6%A0%87%E5%87%86%E5%BA%93/%E5%9B%9B%E3%80%81string%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97&%E6%BA%90%E7%A0%81%E5%88%A8%E6%9E%90/" title="全面理解STL-std::string用法指南&amp;源码刨析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-10-21</div><div class="title">全面理解STL-std::string用法指南&amp;源码刨析</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E9%85%8D%E7%BD%AE/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">一个记录、分享自己学习过程的博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Ming</h1><div class="author-info__desc">MINGの部落格</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/MING-Z0/" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/484647453" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">vector容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-number">1.1.</span> <span class="toc-text">构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E6%9E%84%E9%80%A0"><span class="toc-number">1.1.1.</span> <span class="toc-text">显式构造</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0-explicit-vector-size-t-n"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">指定一个参数 explicit vector(size_t n)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0-explicit-vector-size-t-n-int-const-val"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">指定两个参数 explicit vector(size_t n, int const &amp;val)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%9E%84%E9%80%A0"><span class="toc-number">1.1.2.</span> <span class="toc-text">初始化列表构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">1.1.3.</span> <span class="toc-text">小技巧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#operator"><span class="toc-number">1.2.</span> <span class="toc-text">operator[]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#at-%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">at()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resize-%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">resize()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clear-%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">clear()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push-back-%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">push_back()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pop-back-%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">pop_back()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#back-%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.</span> <span class="toc-text">back()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#front-%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.</span> <span class="toc-text">front()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#data-%E8%8E%B7%E5%8F%96%E9%A6%96%E5%9C%B0%E5%9D%80%E6%8C%87%E9%92%88"><span class="toc-number">1.10.</span> <span class="toc-text">data()获取首地址指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAII%E6%80%9D%E6%83%B3%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">1.11.</span> <span class="toc-text">RAII思想避免内存泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="toc-number">1.12.</span> <span class="toc-text">生命周期管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E7%BB%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.12.1.</span> <span class="toc-text">延续生命周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resize-%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.13.</span> <span class="toc-text">resize()和内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#resize%E5%88%B0%E6%9B%B4%E5%A4%A7%E5%B0%BA%E5%AF%B8%E4%BC%9A%E5%AF%BC%E8%87%B4data%E5%A4%B1%E6%95%88"><span class="toc-number">1.13.1.</span> <span class="toc-text">resize到更大尺寸会导致data失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resize%E5%88%B0%E6%9B%B4%E5%B0%8F%E5%B0%BA%E5%AF%B8%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4data%E5%A4%B1%E6%95%88"><span class="toc-number">1.13.2.</span> <span class="toc-text">resize到更小尺寸不会导致data失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#capacity-%E5%87%BD%E6%95%B0%E6%9F%A5%E8%AF%A2%E5%AE%9E%E9%99%85%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F"><span class="toc-number">1.13.3.</span> <span class="toc-text">capacity()函数查询实际的最大容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resize-%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">1.13.4.</span> <span class="toc-text">resize()的优化策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reserve-%E9%A2%84%E7%95%99%E4%B8%80%E5%AE%9A%E5%AE%B9%E9%87%8F%EF%BC%8C%E9%81%BF%E5%85%8D%E4%B9%8B%E5%90%8E%E9%87%8D%E5%A4%8D%E5%88%86%E9%85%8D"><span class="toc-number">1.13.5.</span> <span class="toc-text">reserve()预留一定容量，避免之后重复分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shrink-t0-fit-%E9%87%8A%E6%94%BE%E5%A4%9A%E4%BD%99%E7%9A%84%E5%AE%B9%E9%87%8F"><span class="toc-number">1.13.6.</span> <span class="toc-text">shrink_t0_fit()释放多余的容量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7%EF%BC%9Amallochook"><span class="toc-number">1.14.</span> <span class="toc-text">一个小工具：mallochook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#puch-back-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.15.</span> <span class="toc-text">puch_back()的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%EF%BC%9Areserve"><span class="toc-number">1.15.1.</span> <span class="toc-text">解决：reserve()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clear-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.16.</span> <span class="toc-text">clear()的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%EF%BC%9Ashrink-to-fit"><span class="toc-number">1.16.1.</span> <span class="toc-text">解决：shrink_to_fit()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%85%A5%E9%97%A8"><span class="toc-number">2.</span> <span class="toc-text">迭代器入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">2.1.</span> <span class="toc-text">迭代器的引入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">迭代器结构的出现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E6%8C%87%E9%92%88-%E5%B0%BE%E6%8C%87%E9%92%88"><span class="toc-number">2.1.2.</span> <span class="toc-text">首指针 + 尾指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.3.</span> <span class="toc-text">模板实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">2.1.4.</span> <span class="toc-text">不连续内存的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E8%BF%AD%E4%BB%A3%E5%99%A8-%E5%B0%BE%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.1.5.</span> <span class="toc-text">首迭代器 + 尾迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%AD-%E7%9A%84%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE"><span class="toc-number">2.1.6.</span> <span class="toc-text">迭代器中++的前置和后置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#insert-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.7.</span> <span class="toc-text">insert()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B4%E9%83%A8%E6%8F%92%E5%85%A5"><span class="toc-number">2.1.7.1.</span> <span class="toc-text">头部插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5"><span class="toc-number">2.1.7.2.</span> <span class="toc-text">特定位置插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5%E5%A4%9A%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%9A%84%E5%80%BC"><span class="toc-number">2.1.7.3.</span> <span class="toc-text">重复插入多个相同的值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">2.1.7.4.</span> <span class="toc-text">直接插入一个初始化列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E5%8F%A6%E4%B8%80%E4%B8%AAvector"><span class="toc-number">2.1.7.5.</span> <span class="toc-text">直接插入另一个vector</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%AF%E6%98%AF%E6%98%AF%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.7.6.</span> <span class="toc-text">数据源可是是不同类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B9%9F%E6%8E%A5%E5%8F%97%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.1.8.</span> <span class="toc-text">构造函数也接受迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#assign-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.9.</span> <span class="toc-text">assign()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#erase-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.10.</span> <span class="toc-text">erase()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.1.10.1.</span> <span class="toc-text">指定位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4"><span class="toc-number">2.1.10.2.</span> <span class="toc-text">指定区间</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/18/AimRT/AimRT%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E6%9E%90/AimRT%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E6%9E%90/" title="AimRT官方示例解析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AimRT官方示例解析"/></a><div class="content"><a class="title" href="/2025/05/18/AimRT/AimRT%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E6%9E%90/AimRT%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E6%9E%90/" title="AimRT官方示例解析">AimRT官方示例解析</a><time datetime="2025-05-17T16:00:00.000Z" title="发表于 2025-05-18 00:00:00">2025-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/04/%E9%9A%8F%E8%AE%B0/sphinx%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="sphinx 使用指南"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="sphinx 使用指南"/></a><div class="content"><a class="title" href="/2025/01/04/%E9%9A%8F%E8%AE%B0/sphinx%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="sphinx 使用指南">sphinx 使用指南</a><time datetime="2025-01-03T16:00:00.000Z" title="发表于 2025-01-04 00:00:00">2025-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/20/CPP/CPP20%E5%8D%8F%E7%A8%8B/CPP20%E5%8D%8F%E7%A8%8B%E5%85%A5%E9%97%A8/" title="C++协程入门"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++协程入门"/></a><div class="content"><a class="title" href="/2024/11/20/CPP/CPP20%E5%8D%8F%E7%A8%8B/CPP20%E5%8D%8F%E7%A8%8B%E5%85%A5%E9%97%A8/" title="C++协程入门">C++协程入门</a><time datetime="2024-11-19T16:00:00.000Z" title="发表于 2024-11-20 00:00:00">2024-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/10/CPP/%E8%AE%BF%E5%AD%98%E4%BC%98%E5%8C%96/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BF%E5%AD%98%E4%BC%98%E5%8C%96/" title="深入浅出访存优化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入浅出访存优化"/></a><div class="content"><a class="title" href="/2024/11/10/CPP/%E8%AE%BF%E5%AD%98%E4%BC%98%E5%8C%96/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BF%E5%AD%98%E4%BC%98%E5%8C%96/" title="深入浅出访存优化">深入浅出访存优化</a><time datetime="2024-11-09T16:00:00.000Z" title="发表于 2024-11-10 00:00:00">2024-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/09/CPP/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/TBB%E5%BC%80%E5%90%AF%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%97%85/" title="TBB开启并行编程之旅"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TBB开启并行编程之旅"/></a><div class="content"><a class="title" href="/2024/11/09/CPP/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/TBB%E5%BC%80%E5%90%AF%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%97%85/" title="TBB开启并行编程之旅">TBB开启并行编程之旅</a><time datetime="2024-11-08T16:00:00.000Z" title="发表于 2024-11-09 00:00:00">2024-11-09</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="/ming-zhanglu@outlook.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/配置/头像.jpg" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/ming-z0" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/484647453" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2025 By <a class="footer-bar-link" href="/" title="Ming" target="_blank">Ming</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  getScript('https://sdk.jinrishici.com/v2/browser/jinrishici.js').then(() => {
    jinrishici.load(result =>{
      if (true) {
        const sub = ["生活明朗&#44; 万物可爱&#44; 人间值得&#44; 未来可期."]
        const content = result.data.content
        sub.unshift(content)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = result.data.content
      }
    })
  })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">7</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://ming-blog.top/" title="MINGの部落格"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/配置/头像.jpg" alt="MINGの部落格"/><span class="back-menu-item-text">MINGの部落格</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/MING-Z0/" title="GitHub"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="GitHub"/><span class="back-menu-item-text">GitHub</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><span> 隧道</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><span> 关于本人</span></a></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AimRT/" style="font-size: 0.88rem;">AimRT<sup>1</sup></a><a href="/tags/CMake/" style="font-size: 0.88rem;">CMake<sup>2</sup></a><a href="/tags/CPP/" style="font-size: 0.88rem;">CPP<sup>21</sup></a><a href="/tags/CUDA/" style="font-size: 0.88rem;">CUDA<sup>10</sup></a><a href="/tags/STL/" style="font-size: 0.88rem;">STL<sup>5</sup></a><a href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" style="font-size: 0.88rem;">并行计算<sup>12</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" style="font-size: 0.88rem;">开发环境<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">开发语言<sup>5</sup></a><a href="/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/" style="font-size: 0.88rem;">机器人<sup>1</sup></a><a href="/tags/%E8%AE%BF%E5%AD%98%E4%BC%98%E5%8C%96/" style="font-size: 0.88rem;">访存优化<sup>1</sup></a><a href="/tags/%E9%9A%8F%E8%AE%B0/" style="font-size: 0.88rem;">随记<sup>5</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="12875524711" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.5"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/my/m/music/playlist?id=12875524711&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2021 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://vercel-c6qs1so68-mings-projects-7cb05430.vercel.app/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://vercel-c6qs1so68-mings-projects-7cb05430.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://vercel-c6qs1so68-mings-projects-7cb05430.vercel.app/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@ming.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>